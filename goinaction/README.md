# Go-In-Action
```
@author 鲁伟林
记录《Go语言实战》中各章节学习过程，写下一些自己的思考和总结。希望维护管理此仓库，记录学习过程中部分心得，以与其他同行参考。

本博客中涉及的完整代码：
GitHub地址: https://github.com/thinkingfioa/go-learning
本人博客地址: https://blog.csdn.net/thinking_fioa
文中如若有任何错误，欢迎指出。个人邮箱: thinking_fioa@163.com
```

## 第1章 Go语言开始

### 1.1 Go语言介绍
Go语言的出现，实则为并发而出现的语言也不过为。Java语言中利用多线程机制可以较为方便的实现程序并发，提高程序并发度。Go语言并发较于Java更加细化，在线程基础，利用goroutine再并发一次，粒度更小。

学习Go语言最重要的是学会写并发，也就是写goroutine和通道(channel)

### 1.2 Go语言环境配置
鄙人写Go语言是使用GoLand工具。推荐使用。GoLand安装和Go语言环境安装自行Google或百度即可。

### 1.3 官方源码地址
项目中源码基本原型来自于《Go语言实战》书本中。书本源码情参考[地址](https://github.com/goinaction/code)

## 第2章 快速开始一个Go程序

### 2.1 项目总结 

### 2.2 技术总结

## 第3章 打包和工具链

### 3.1 包
1. 同一个目录下的.go文件必须声明同一个包名
2. main包 ---- 命名为main的包具有特殊意义：使用声明main的包的代码所在的目录名作为二进制可执行文件的文件名

### 3.2 导入
1. import导入包顺序 ---- 编译器首先查找Go的安装目录(GOROOT)，然后才会按照顺序超招GOPATH变量里列出的目录
2. 命名导入 ---- 在import语句给出包路径的左侧定义一个名字，将导入的包命名为新的名字（用于解决重名的包）。如果只是导入而不想使用，使用下划线字符(_)（空白标识符）

### 3.3 函数init
init函数在程序执行开始的时候被调用。所有被编译器发现的init函数都会安排在main函数之前执行

### 3.4 使用Go的工具
1. go build ---- 编译
2. go clean ---- 清理
3. go run ---- 执行

### 3.5 进一步介绍Go开发工具

##### 3.5.1 Go代码格式化
go fmt用户格式化Go语言代码。GoLand工具可以在Go文件保存之前自动格式化，配置方式: Tools -> File Watchers -> go fmt

##### 3.5.2 Go语言依赖管理工具
TODO:::: dep依赖管理工具学习

## 第4章 数组、切片和映射
Go语言有3种数据结构来管理集合：数组、切片和映射

### 4.1 数组的内部实现和基础功能
数组是一组长度固定的数据类型，用于存储一段具有相同类型的元素的连续块。数组的每个元素类型都是相同，又是连续分配，可通过索引快速查找到对应的数据。

- 数组创建完成后，存储的数据类型和数组长度就不再允许改变。

#### 4.1.2 声明和初始化
##### 4.1.2.1 var声明
使用var变量声明类型时，总是会用对应类型的零值对变量进行初始化。

```
// 数组array中每个元素都初始化为0
var array [5]int
```

##### 4.1.2.2 数组字面量
1. 直接创建并初始化数组
2. 可以使用...来替代数组长度
3. 声明数组并指定特定索引位置的值

```
array := [5]int {1,2,3,4,5}
// 使用...来替代数组长度
array := [...]int {1,2,3,4,5}
// 声明数组并指定特定元素的值。只有下标为1的值为10，下标为4的值为40
array := [5]int {1:10 ,4: 40}
```

#### 4.1.3 使用数组
使用[]运算符来访问数组里的某个单独元素

```
array := [5]int {10, 20, 30, 40, 50}
array[2]=35
```

##### 4.1.3.1 指针数组
声明一个指针数组，使用*运算符访问元素

```
array := [5]*int{0: new(int), 1: new(int)}
*array[0]=10
*array[1]=20
```

##### 4.1.3.2 数组赋值操作
1. 数组长度和元素类型一样，可直接赋值操作。赋值后两个数组之间拥有各自的底层数据，修改相互不影响
2. 复制指针数组，只会复制指针的地址，而不会复制指针所指向的值。赋值后两个数组指针共享底层数据，修改相互影响

```
package main

import "fmt"

func main() {
	var array1 [3]*string

	array2 := [3]*string{new(string), new(string), new(string)}
	*array2[0] = "Red"
	*array2[1] = "Blue"
	*array2[2] = "Green"

	array1 = array2

	*array1[0] = "Yellow"
	// 遍历
	for index := range array1 {
		fmt.Println(*array1[index])
	}

	// 遍历
	for index := range array2 {
		fmt.Println(*array1[index])
	}
}
```

#### 4.1.4 多维数组
多维数组的特性与一维数组特性完全一致。包括初始化、遍历，赋值等特性

```
array := [4][2]int{{10,11},{20,21},{30,31},{40,41}}
```

#### 4.1.5 在函数间传递数组
Go语言函数之间传递变量，总是以值的方式传递。如果这个变量是数组，不管都长，都会完整复制一份。所以数组作为函数参数传递，将严重影响程序的内存和性能。

推荐的方式是传入指向数组的指针，但是要提醒的是：如果传递的是指针，改变指针指向的值，会改变共享的内存，对原数组有影响，请慎重处理。

### 4.2 切片的内部实现和基础功能
切片是围绕着动态数组，切片的底层内存也是在连续块中分配。但其与数组在内部实现和基础功能存在较多不同点。类似于Netty的ByteBuf中的slice(切片)概念。

切片与数组最大的不同点是：切片为共享而生。基于一个切片创建新的切片，新的切片会和原有的切片共享底层数组。

#### 4.2.1 内部实现
切片由3个字段组成，分别是：执行底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长到的元素个数（即容量）。如下图
![](./pictures/4-1.png)

#### 4.2.2 创建和初始化
Go语言中有几种方法可以创建和初始化切片

##### 4.2.2.1 make函数
内置的make函数创建切片，需要传入一个参数，制定切片的长度。也可以同时指定长度和容量。

```
// 创建字符串切片，其长度和容量都是5个元素
slice := make([]string, 5)
// 创建一个整型切片，其长度为3，容量为5
slice := make([]string, 3, 5)
```

##### 4.2.2.2 切片字面量
另一种常见的创建切片的方法是使用切片字面量

```
// 创建字符串切片
slice := []string {"Red", "Blue", "Yellow"}
// 创建长度和容量都为100的整型切片
slice := []int {100: 1000}
```

##### 提醒
使用切面量创建数组和切片非常相似。如果[]运算符里指定了一个值，那么创建的就是数组而不是切片

```
// 创建3个元素的整型数组
array := [3]int {1,2,3}
// 创建长度和容量都是3的切片
array := []int{1,2,3}
```

##### 4.2.2.3 nil和空切片
创建nil的切片 ----- val slice []int
![](./pictures/4-10.png)

创建空切片

```
// 使用make创建空的整型切片
slice := make([]int, 0)
// 使用make创建空的整型切片
slice := []int {}
```

#### 4.2.3 使用切片

##### 4.2.3.1 赋值和切片
对切片里某个索引执行的元素赋值和对数组里的某个索引指向的元素赋值的方法完全一样

```
slice := []int {1,2,3}
slice[2] = 4
```

基于一个切片创建出新的切片，新的切片和原来的切片共享一个底层数组，如下代码和图

```
// 如上图所示
slice := []int {10, 20, 30, 40, 50}
// 创建一个新的切片
newSlice := slice[1:3]
```
![](./pictures/4-12.png)

计算:

1. 如何计算新切片的长度和容量. slice[i:j] ----- 长度=j-i, 容量=k-i，其中k是原切片容量
2. slice[i:j:k] ----- 长度=j-i, 容量=k-i。推荐使用该方式

##### 4.2.3.2 切片增长 ----- append函数
相对于数组，使用切片的一个好处是：可按需增加切片的容量。Go语言里使用append函数来实现，append函数可同时追加多个值

函数append总是会增加新切片的长度，当容量不够时，append函数会创建一个新的底层数组，将原有的值复制进去，再追加新的值。与其他语言的可变长度数组扩容逻辑基本类似。所以一次性分配足够的容量，可有效减少扩容时间。

```
package main

import "fmt"

func main() {
	slice := []int{10, 20, 30, 40, 50}

	newSlice := slice[2:5:5]

	newSlice = append(newSlice, 60)
	fmt.Println("Slice :")
	for index, value := range slice {
		fmt.Println("Index %d, Value: %d", index, value)
	}
	fmt.Println("NewSlice :")
	for index, value := range newSlice {
		fmt.Println("Index %d, Value: %d", index, value)
	}
}
```

##### 4.2.3.3 创建切片时的3个索引
推荐创建切片时，使用三个值。如：slice[i:j:k]。第三个值k是用来控制新切片的容量，其目的是限制容量，防止误操作改变了原切片的底层数据。

slice[i:j:k] ----- 长度=j-i, 容量=k-i。k(容量)和j(长度)设置成一样，可防止底层误操作。当新切片容量不够时，append函数会自动进行扩容，与原切片底层分离，而不会修改原切片的值。

append函数可同时追加多个值，如果使用...运算符，可将一个切片的所有元素追加到另一个切片里。eg: newSlice = append(slice1, slice2...)

##### 4.2.3.4 迭代切片

关键字range迭代。关键字range会返回两个值，第一个是索引的位置（可用下划线忽略索引值），第二个是该位置对应元素值的一份副本。

```
for index, value := range slice {
	fmt.Println("index %d, value: %d", index, value)
}
```

传统的for循环方式迭代

```
for index:0; index < len(slice); index++ {
	fmt.Println("index %d, value %d", index, slice[index]);
}
```

注：对于切片，函数len返回切片的长度，函数cap返回切片的容量

#### 4.2.4 多维切片
切片是一维的，也可以创建多维切片。eg: slice := [][]int {{10}, {100, 200}}

append函数同样适用于多维切片。eg: slice[0] = append(slice[0], 2)

![](./pictures/4-20.png)

#### 4.2.5 在函数间传递切片
函数间传递切片，只是切片自身值(切片的3个字段)被复制一份，不会涉及底层数组。在函数间传递切片代价非常小。

### 4.3 映射的内部实现和基础功能
映射是一种数据结构，用于存储一系列无序的键值对。映射是一种无序的集合，意味着没有办法预测键值对被返回的顺序

#### 4.3.2 创建和初始化
映射的创建和初始化与数组、切片的方式一样，第一种：使用内置的make函数，第二种：使用映射字面量

映射的键可以是任何值。但是切片、函数以及包含切片的结构类型都具有引用语义，不能作为映射的键

##### 4.3.2.1 make函数
如下代码生声明一个键的类型是string，值的类型是int

```
// 声明一个键的类型是string，值的类型是int
dict := make(map[string]int)
```

##### 4.3.2.2 使用映射字面量

```
// 声明一个键的类型是string，值的类型是string
dict := map[string]string {"red": "1", "blue": "2", "yellow": "3"}
```

#### 4.3.3 使用映射
映射取值有两种选择。

第一种选择是，可以同时获得值，以及一个表示这个键是否存在的标志

```
// 第一种方法
ageValue, exist := dict["age"]
if exist {
	fmt.Println("age is  %s", ageValue)
}
```

第二种选择是，只返回对应的值，然后再通过判断这个值是不是对应类型的零值来确定键是否存在

```
// 第二中方法
phoneValue := dict["phone"]
if "" != phoneValue {
	fmt.Println("phone is %d", phoneValue)
}
```

#### 删除映射中的键
如果想把一个键值对从映射中删除，可使用内置的delete函数, eg: delete(dict, "age")

#### 遍历映射
遍历映射，使用range关键字。关键字range返回的不是索引和值，而是键值对

```
// 遍历
for key, value := range dict {
	fmt.Println("key is %s, value is %s", key, value)
}
```

#### 4.3.4 在函数间传递映射
在函数之间传递映射，并不会制造出该映射的一个副本。实际上传递映射给一个函数时，在函数中如果对该映射做了修改，所有对这个映射的引用都会觉察到这个修改。该特性与切片类似，保证使用最小的成本来复制映射

## 第5章 Go语言的类型系统
Go语言是静态编译的语言。Go语言提供基本类型，同时也允许用户自定义类型

### 5.1 用户定义类型
Go语言里声明用户定义的类型有两种方法，第一种：使用关键字struct（最常用），第二种：基于一个已有的类型，将其作为新类型

#### 5.1.1 使用关键字struct定义类型
使用关键字struct定义类型。如下代码：

```
type user struct {
	name  string
	email string
}
```

##### 5.1.1.1 使用关键字var声明
使用var声明变量时，这个变量对应的值总是会被初始化。如: var wllu user。对于数值类型来说，零值是0； 对于字符串来说，零值是空串；对于布尔类型，零值是false

##### 5.1.1.2 结构字面量
使用结构字面量和短变量声明操作符来创建变量。其中（:=）称之为短变量声明操作符。

##### 声明每个字段的名字以及对应的值
声明每个字段的名字以及对应的值

```
u := user {
	name: "thinking",
	email: "thinking_fioa@163.com",
}
```

##### 没有字段名，只声明对应的值

```
// 没有字段名，只声明对应的值
u := user{"thinking", "thinking_fioa@163.com"}
```

#### 5.1.2 基于已有的类型，将其作为新类型的类型
使用关键字type，类型于重命名，但编译器不会对不同的类型的值做隐式转换。该方式提高了可读性。eg: type Duration int64

### 5.2 方法
方法能给用户定义的类型添加新的行为。方法实际上也是函数，只是在声明时，在关键字func和方法名之间添加一个参数。

关键字func和函数名之间的参数被称为**接收者**。Go语言里有两种类型的接收者：值接收者和指针接收者

Go语言既允许使用值，也允许使用指针来调用方法，不必严格符合接收者的类型。Go语言编译器会自动帮助转换，以符合方法声明的接收者。

#### 5.2.1 值接收者

```
func (u user) notify() {}
```
值接收者调用时会使用这个值的一个副本来执行，意味着你对这个值的副本做了任何修改，原来调用者不受影响

#### 5.2.2 指针接受者

```
func (u *user) notify() {}
```
指针接收者使用实际的值来执行，意味着方法中对值的做了任何修改，原来的值将同步变化

#### 总结
值接收者使用值的副本来调用方法，而指针接收者使用实际值来调用方法

### 5.3 类型的本质
为一个类型添加方法时，需要考虑该类型的方法是值接收者还是指针接受者。如果是要创建一个新值，就使用值接收者。如果是要修改当前值，就使用指针接收者。

#### 5.3.1 内置类型
数值类型、字符串类型和布尔类型都是内置类型。内置类型都是以副本在方法或函数间传递，对这些值进行增加或者删除的时候，会创建一个新值。

#### 5.3.2 引用类型
Go语言中的引用类型有如下几个：切片、映射、通道、接口和函数类型。通过复制来传递一个引用类型的值的副本，本质上是在共享底层数据结构。

#### 5.3.3 结构类型
原始本质的类型和非原始本质类型。原始本质类型指的是应该被复制，而不应该被共享的类型。非原始本质类型指的是应该被共享，不应该被复制。

是使用值接收者还是指针接收者，不应该由该方法是否修改了接收到的值来决定。这个决策应该基于该类型的本质。这个规则由一个例外，需要让类型值符合某个接口时，即便类型的本质是非原始的，也可以使用值接收者声明方法。

### 5.4 接口
接口的出现是为了实现多态。多态是指代码可以根据类型的值的具体实现采取不同行为的能力。

#### 5.4.2 实现
接口是用来定义行为的类型。如果用户定义的类型实现了某个接口类型声明的一组方法，那么这个用户定义的类型的值就可以赋给这个接口类型的值。用于定义的类型的值通常称为实体类型。

接口值分为两种，第一个：实体值赋值给接口值，第二个：实体指针赋值给接口值。接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表(iTable)的指针，包含了所存储的值的类型信息。第二个字是一个指向所存储值的指针

![](./pictures/5-1.png)

![](./pictures/5-2.png)


#### 5.4.3 方法集
方法集定义了一组关联到给定类型的值或者指针的方法。定义方法时使用的接收者的类型决定了这个方法关联到值，还是关联到指针，还是两个都关联。请与5.2章节区分，这里Go语言编译器不会自动帮助转换。

从接收者的角度看这些规则：
![](./pictures/list5-43.png)

如果使用值接收者来实现一个接口，那么那个类型的值和指针都能赋值给对应的接口。如果使用指针接收者实现一个接口，那么只能指向那个类型的指针才能赋值给对应的接口。如有不懂，可参考listing36.go和listing36P.go帮助理解

### 5.5 嵌入类型
Go语言允许用户扩展或修改已有类型的行为，这对于代码复用很有好处。这个功能是通过嵌入类型实现的。**嵌入类型是将已有的类型直接声明在新的结构类型里**。

通过嵌入类型，与内部类型相关的标识符会提升到外部类型上。这些被提升的标识符就像直接声明在外部类型里的标识符一样，也是外部类型的一部分。这样外部类型就组合了内部类型包含的所有属性，并且可以添加新的字段和方法。外部类型可通过声明与内部类型标识符同名的标识符来覆盖内部标识符的字段或方法。

```
type notifier interface {
	notify()
}

type user struct {
	name  string
	email string
}

func (u user) notify() {
	fmt.Printf("name %s, email %s\n", u.name, u.email)
}

type admin struct {
	user
	password string
}

func main() {

	ad := admin{
		user: user{
			name:  "thinking_fioa",
			email: "thinking_fioa@163.com",
		},
		password: "123456",
	}
	// 可以直接访问内部类型的方法
	ad.user.notify()
	// 内部类型的方法也被提升到外部类型中
	ad.notify()
}
```
注：

1. 要嵌入一个类型，只需要声明这个类型的名字就可以了
2. 通过嵌入类型，与内部类型相关的标识符(包括属性和方法)会提升到外部类型上
3. 通过内部类型的名字可以访问内部类型的值
4. 由于内部类型相关的标识符被提升到外部类型上，也可以直接通过外部类型访问
5. 内部类型的提升，内部类型实现的接口会自动提升到外部类型。外部类型(admin)也实现了接口(notifier)

外部类型可通过声明与内部类型标识符同名的标识符来覆盖内部标识符的字段或方法。亦可实现对应的接口

```
type notifier interface {
	notify()
}

type user struct {
	name  string
	email string
}

func (u user) notify() {
	fmt.Printf("name is %s, email is %s\n", u.name, u.email)
}

type admin struct {
	user
	password string
}

func (ad admin) notify() {
	fmt.Printf("name is %s, email is %s, passwd is %s\n", ad.name, ad.email, ad.password)
}

func main() {
	ad := admin{
		user: user{
			name:  "thinking",
			email: "thinking_fioa@163.com",
		},
		password: "123456",
	}

	sendNotification(ad.user)
	sendNotification(ad)
}

func sendNotification(n notifier) {
	n.notify()
}
```
注：

1. 由于内部类型的提升，内部类型实现的接口会自动提升到外部类型。这就意味着由于内部类型的实现，外部类型也同样实现了这个接口
2. 如果外部类型覆盖内部标识符的方法，则内部类型的实现将不会被提升。不过内部类型的值一直存在，可通过内部类型的值来调用内部实现的方法。

### 5.6 公开或未公开的标识符
Go语言支持从包里公开或者隐藏标识符。当一个标识符的名字以小写字母开头时，表示这个标识符未公开，即包外的代码不可见。如果一个标识符以大写字母开头，表示该标识符是公开的，包外的代码可见。通常将代码所在的文件夹名作为包名

```
package counters
type alertCounter int


func New(value int) alertCounter {
	return alertCounter(value)
}
```
```
import (
	"./counters"
	"fmt"
)

func main() {
	counter := counters.New(1)
	fmt.Printf("count %d", counter)
}
```
注：

1. 将工厂函数命名为New是Go语言的一个习惯
2. New函数返回了一个未公开的alertCount类型的值。原因有两个，第一，标识符才有公开或者未公开，值永远没有。第二，短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的的类型变量。

```
package entities

type user struct {
	Name  string
	Email string
}

type Admin struct {
	user
	Passwd string
}
```
```
import (
	"./entities"
	"fmt"
)

func main() {

	ad := entities.Admin{
		Passwd: "123456",
	}
	ad.Name = "thinking"
	ad.Email = "thinking_fiao@163.com"

	fmt.Printf("name %s, email %s, passwd %s", ad.Name, ad.Email, ad.Passwd)
}
``` 
注：

1. 内部类型user未公开，无法直接通过结构字面量的方式初始化内部类型
2. 内部类型的标识符全部被提升至外部类型，所以这些公开的字段(Name、Email)可通过外部类型的值直接来访问

















